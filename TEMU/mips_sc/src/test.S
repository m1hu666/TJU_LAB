# MIPS分指令测试程序：逐一验证指定I-type/R-type指令
# 寄存器约定：
# $t0-$t7: 临时测试寄存器（存放操作数/中间结果）
# $s0-$s7: 结果存储寄存器（存放指令执行结果，便于查看）
# $zero: 恒零寄存器（$0，值始终为0）
# $sp: 栈指针（默认对齐，暂未使用）

    .data
    .align 2  # 强制4字节对齐，避免lw/sw地址错误
test_word:  .word   0x5A5A5A5A    # 用于lw/sw测试的32位对齐数据
test_byte:  .byte   0x7F          # 用于lb/sb测试的8位有符号数据（+127）
empty_word: .space  4             # 空字存储单元（4字节，对齐）
empty_byte: .space  1             # 空字节存储单元

    .text
    .globl main
main:
    # ==================== 1. ORI 测试（零扩展立即数按位或）====================
    # 功能：rs寄存器值 | 零扩展16位立即数 → rt
    li      $t0, 0xABCD0000       # $t0 = 0xABCD0000
    ori     $s0, $t0, 0x1234      # $s0 = 0xABCD0000 | 0x00001234 = 0xABCD1234
    # 验证：$s0 应为 0xABCD1234

    # ==================== 2. LUI 测试（高位加载立即数）====================
    # 功能：将16位立即数加载到rt寄存器的高16位，低16位置0
    lui     $s1, 0x1234           # $s1 = 0x12340000
    # 验证：$s1 应为 0x12340000

    # ==================== 3. ADDU 测试（无符号加法，不触发溢出）====================
    # 功能：rs + rt（无符号）→ rd，忽略溢出
    li      $t1, 0x80000000       # 无符号数：2147483648
    li      $t2, 0x80000000       # 无符号数：2147483648
    addu    $s2, $t1, $t2         # $s2 = 0x100000000（截断为32位：0x00000000）
    # 验证：$s2 应为 0x00000000（无符号加法截断结果）

    # ==================== 4. BNE 测试（不等则跳转）====================
    # 功能：若rs != rt，则跳转到指定偏移地址
    li      $t3, 0x11111111
    li      $t4, 0x22222222
    bne     $t3, $t4, bne_success # $t3 != $t4，应跳转至bne_success
bne_failure:
    li      $s3, 0xFFFFFFFF       # 跳转失败则置为0xFFFFFFFF
    j       andi_test             # 跳过成功分支
bne_success:
    li      $s3, 0x00000000       # 跳转成功则置为0x00000000
    # 验证：$s3 应为 0x00000000

    # ==================== 5. ANDI 测试（零扩展立即数按位与）====================
andi_test:
    # 功能：rs寄存器值 & 零扩展16位立即数 → rt
    li      $t5, 0xABCD1234       # $t5 = 0xABCD1234
    andi    $s4, $t5, 0xFF00      # $s4 = 0xABCD1234 & 0x0000FF00 = 0x00001200
    # 验证：$s4 应为 0x00001200

    # ==================== 6. OR 测试（寄存器按位或）====================
    # 功能：rs | rt → rd
    li      $t6, 0xFFFF0000       # $t6 = 0xFFFF0000
    li      $t7, 0x00FFFF00       # $t7 = 0x00FFFF00
    or      $s5, $t6, $t7         # $s5 = 0xFFFF0000 | 0x00FFFF00 = 0xFFFFFF00
    # 验证：$s5 应为 0xFFFFFF00

    # ==================== 7. XOR 测试（寄存器按位异或）====================
    # 功能：rs ^ rt → rd
    xor     $s6, $t6, $t7         # $s6 = 0xFFFF0000 ^ 0x00FFFF00 = 0xFF00FF00
    # 验证：$s6 应为 0xFF00FF00

    # ==================== 8. ADDIU 测试（有符号立即数加法，不触发溢出）====================
    # 功能：rs + 符号扩展16位立即数 → rt，忽略溢出
    addiu   $s7, $zero, -500      # $s7 = 0 + (-500) = 0xFFFFFE0C
    # 验证：$s7 应为 0xFFFFFE0C

    # ==================== 9. BEQ 测试（相等则跳转）====================
    # 功能：若rs == rt，则跳转到指定偏移地址
    li      $t0, 0x33333333
    li      $t1, 0x33333333
    beq     $t0, $t1, beq_success # $t0 == $t1，应跳转至beq_success
beq_failure:
    li      $t2, 0xFFFFFFFF       # 跳转失败则置为0xFFFFFFFF
    j       lb_test               # 跳过成功分支
beq_success:
    li      $t2, 0x00000000       # 跳转成功则置为0x00000000
    # 验证：$t2 应为 0x00000000

    # ==================== 10. LB 测试（字节加载，符号扩展）====================
lb_test:
    # 功能：从内存读取1字节，符号扩展为32位 → rt
    la      $t3, test_byte        # $t3 = test_byte的对齐地址
    lb      $t4, 0($t3)           # 读取0x7F，符号扩展后为0x0000007F
    # 验证：$t4 应为 0x0000007F
    lb      $t5, 1($t3)           # 读取空字节（默认0），符号扩展后为0x00000000
    # 验证：$t5 应为 0x00000000

    # ==================== 11. SB 测试（字节存储，截断低8位）====================
    # 功能：将rt寄存器的低8位写入内存
    li      $t6, 0x12345678       # 低8位为0x78
    la      $t7, empty_byte       # $t7 = empty_byte地址
    sb      $t6, 0($t7)           # 将0x78写入empty_byte
    # 验证：empty_byte地址内存值应为0x78

    # ==================== 12. SLL 测试（逻辑左移，移位量为立即数）====================
    # 功能：rt << sa（移位量，5位）→ rd
    li      $t0, 0x00000001       # $t0 = 1
    sll     $t1, $t0, 5           # $t1 = 1 << 5 = 0x00000020
    # 验证：$t1 应为 0x00000020

    # ==================== 13. ADD 测试（有符号加法，无溢出）====================
    # 功能：rs + rt（有符号）→ rd，溢出触发例外
    li      $t2, 0x0000FFFF       # $t2 = 65535
    li      $t3, 0x00000001       # $t3 = 1
    add     $t4, $t2, $t3         # $t4 = 65536 = 0x00010000
    # 验证：$t4 应为 0x00010000（无溢出）

    # ==================== 14. SRAV 测试（算术右移，移位量来自寄存器）====================
    # 功能：rt 算术右移 rs的低5位 → rd（符号位填充）
    li      $t5, 0x80000000       # $t5 = -2147483648（有符号数）
    li      $t6, 2                # 移位量=2
    srav    $t7, $t5, $t6         # $t7 = -2147483648 >> 2 = 0xC0000000
    # 验证：$t7 应为 0xC0000000

    # ==================== 15. BLEZ 测试（小于等于0则跳转）====================
    # 功能：若rs <= 0（有符号），则跳转到指定偏移地址
    li      $t0, -10              # $t0 = -10（<=0）
    blez    $t0, blez_success     # 应跳转至blez_success
blez_failure:
    li      $t1, 0xFFFFFFFF       # 跳转失败则置为0xFFFFFFFF
    j       lw_test               # 跳过成功分支
blez_success:
    li      $t1, 0x00000000       # 跳转成功则置为0x00000000
    # 验证：$t1 应为 0x00000000

    # ==================== 16. LW 测试（字加载，32位对齐）====================
lw_test:
    # 功能：从内存读取32位字 → rt（地址必须4字节对齐）
    la      $t2, test_word        # $t2 = test_word的对齐地址
    lw      $t3, 0($t2)           # $t3 = 0x5A5A5A5A
    # 验证：$t3 应为 0x5A5A5A5A

    # ==================== 17. SW 测试（字存储，32位对齐）====================
    # 功能：将rt寄存器的32位值写入内存（地址必须4字节对齐）
    li      $t4, 0xAAAAAAAA       # 待存储的32位数据
    la      $t5, empty_word       # $t5 = empty_word的对齐地址
    sw      $t4, 0($t5)           # 将0xAAAAAAAA写入empty_word
    # 验证：empty_word地址内存值应为0xAAAAAAAA

# 程序结束：无限循环，便于查看寄存器/内存值
end_loop:
    j       end_loop
    nop