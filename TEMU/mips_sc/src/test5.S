# test5.S - 数据前推（Forwarding）测试
# 测试RAW (Read After Write) 冒险和前推机制
# 入口地址：0x80000000

    .text
    .globl _start
    .org 0x0000
_start:
    # EXE->ID 前推测试（相邻指令）
    ori  $1, $0, 100        # $1 = 100
    addu $2, $1, $1         # $2 = $1 + $1 = 200 (需要从EXE前推$1)
    addu $3, $2, $2         # $3 = $2 + $2 = 400 (需要从EXE前推$2)
    addu $4, $3, $3         # $4 = $3 + $3 = 800 (需要从EXE前推$3)
    
    # MEM->ID 前推测试（间隔一条指令）
    ori  $5, $0, 50         # $5 = 50
    ori  $6, $0, 1          # 中间指令
    addu $7, $5, $5         # $7 = $5 + $5 = 100 (需要从MEM前推$5)
    
    # 连续数据依赖链
    ori  $8, $0, 10         # $8 = 10
    addiu $9, $8, 5         # $9 = $8 + 5 = 15
    addiu $10, $9, 5        # $10 = $9 + 5 = 20
    addiu $11, $10, 5       # $11 = $10 + 5 = 25
    addiu $12, $11, 5       # $12 = $11 + 5 = 30
    
    # 多个源操作数依赖
    ori  $13, $0, 8         # $13 = 8
    ori  $14, $0, 7         # $14 = 7
    addu $15, $13, $14      # $15 = 8 + 7 = 15
    addu $16, $15, $13      # $16 = 15 + 8 = 23 (两个源都需要前推)
    subu $17, $16, $15      # $17 = 23 - 15 = 8 (两个源都需要前推)
    
    # 逻辑指令前推
    lui  $18, 0xFF00
    ori  $18, $18, 0x00FF   # $18 = 0xFF0000FF
    and  $19, $18, $18      # $19 = $18 & $18 = $18
    or   $20, $18, $19      # $20 = $18 | $19 (前推$19)
    xor  $21, $19, $20      # $21 = $19 ^ $20 (前推两个)
    
    # 移位指令前推
    ori  $22, $0, 0xFF      # $22 = 0xFF
    sll  $23, $22, 8        # $23 = 0xFF00
    sll  $24, $23, 8        # $24 = 0xFF0000 (前推$23)
    ori  $25, $0, 8
    srav $26, $24, $25      # $26 = 0xFF0000 >>> 8 (前推$24和$25)
    
    # 比较指令前推
    ori  $27, $0, 100       # $27 = 100
    ori  $28, $0, 50        # $28 = 50
    slt  $29, $28, $27      # $29 = (50 < 100) = 1 (前推两个)
    slt  $30, $27, $29      # $30 = (100 < 1) = 0 (前推$29)
    
    # 分支指令前推测试
    ori  $1, $0, 10
    ori  $2, $0, 10
    beq  $1, $2, branch1    # 比较两个刚写入的寄存器
    nop
    ori  $3, $0, 0xBAD1     # 不应执行
    
branch1:
    ori  $3, $0, 0x0001     # $3 = 1
    
    # Store指令前推测试
    lui  $28, 0x8000
    ori  $28, $28, 0x1000   # 数据段基地址
    ori  $4, $0, 0xABCD
    sw   $4, 0($28)         # 存储刚计算的值
    ori  $5, $0, 0x1234
    sb   $5, 4($28)         # 存储字节
    
    # 复杂前推场景：三个连续依赖
    ori  $6, $0, 1
    sll  $7, $6, 1          # $7 = 2
    sll  $8, $7, 1          # $8 = 4 (从EXE前推$7)
    sll  $9, $8, 1          # $9 = 8 (从EXE前推$8)
    sll  $10, $9, 1         # $10 = 16 (从EXE前推$9)
    
    # 前推优先级测试：EXE > MEM > REG
    ori  $11, $0, 0x1111    # REG中的值
    ori  $12, $0, 1
    ori  $11, $0, 0x2222    # EXE中的新值
    addu $13, $11, $12      # 应该使用EXE中的0x2222
    
    # 多路径前推
    ori  $14, $0, 5
    ori  $15, $0, 3
    addu $16, $14, $15      # $16 = 8
    subu $17, $14, $15      # $17 = 2 (同时使用$14和$15)
    and  $18, $16, $17      # $18 = 8 & 2 = 0 (前推$16和$17)
    
    # 无依赖指令（无需前推）
    ori  $19, $0, 0xAAAA
    ori  $20, $0, 0xBBBB
    ori  $21, $0, 0xCCCC
    or   $22, $19, $20      # 不需要前推（有足够的间隔）
    
    # 结束
    ori  $31, $0, 0xFFFF
    
_end:
    beq  $0, $0, _end
    nop
