# test4.S - Load/Store指令测试
# 测试：LW, LB, SW, SB 以及不同的地址对齐和偏移
# 入口地址：0x80000000
# 数据段假设从0x80001000开始

    .text
    .globl _start
    .org 0x0000
_start:
    # 初始化基地址（假设数据段在0x80001000）
    lui  $28, 0x8000        # $28 = 0x80000000
    ori  $28, $28, 0x1000   # $28 = 0x80001000 (数据段基地址)
    
    # 准备测试数据
    lui  $1, 0x1234
    ori  $1, $1, 0x5678     # $1 = 0x12345678
    lui  $2, 0xABCD
    ori  $2, $2, 0xEF00     # $2 = 0xABCDEF00
    ori  $3, $0, 0x00FF     # $3 = 0x000000FF
    ori  $4, $0, 0x0080     # $4 = 0x00000080
    
    # SW测试：存储字
    sw   $1, 0($28)         # [0x80001000] = 0x12345678
    sw   $2, 4($28)         # [0x80001004] = 0xABCDEF00
    sw   $3, 8($28)         # [0x80001008] = 0x000000FF
    sw   $0, 12($28)        # [0x8000100C] = 0x00000000
    
    # SB测试：存储字节
    sb   $3, 16($28)        # [0x80001010] = 0xFF (byte 0)
    sb   $3, 17($28)        # [0x80001011] = 0xFF (byte 1)
    sb   $3, 18($28)        # [0x80001012] = 0xFF (byte 2)
    sb   $3, 19($28)        # [0x80001013] = 0xFF (byte 3)
    # [0x80001010-13]应该是 0xFFFFFFFF
    
    sb   $4, 20($28)        # [0x80001014] = 0x80 (byte 0)
    sb   $0, 21($28)        # [0x80001015] = 0x00 (byte 1)
    sb   $0, 22($28)        # [0x80001016] = 0x00 (byte 2)
    sb   $0, 23($28)        # [0x80001017] = 0x00 (byte 3)
    # [0x80001014-17]应该是 0x00000080 (小端)
    
    # LW测试：加载字
    lw   $5, 0($28)         # $5 = [0x80001000] = 0x12345678
    lw   $6, 4($28)         # $6 = [0x80001004] = 0xABCDEF00
    lw   $7, 8($28)         # $7 = [0x80001008] = 0x000000FF
    lw   $8, 12($28)        # $8 = [0x8000100C] = 0x00000000
    lw   $9, 16($28)        # $9 = [0x80001010] = 0xFFFFFFFF
    
    # 验证加载的数据
    beq  $5, $1, lw_test1_pass
    ori  $10, $0, 0xE001    # 错误标记
lw_test1_pass:
    ori  $10, $0, 0x0001    # $10 = 1
    
    beq  $6, $2, lw_test2_pass
    ori  $11, $0, 0xE002
lw_test2_pass:
    ori  $11, $0, 0x0002    # $11 = 2
    
    # LB测试：加载字节（符号扩展）
    lb   $12, 0($28)        # $12 = [0x80001000]的byte0 = 0x78 -> 0x00000078
    lb   $13, 1($28)        # $13 = [0x80001001]的byte1 = 0x56 -> 0x00000056
    lb   $14, 2($28)        # $14 = [0x80001002]的byte2 = 0x34 -> 0x00000034
    lb   $15, 3($28)        # $15 = [0x80001003]的byte3 = 0x12 -> 0x00000012
    
    # LB负数测试（符号扩展）
    lb   $16, 4($28)        # $16 = [0x80001004]的byte0 = 0x00 -> 0x00000000
    lb   $17, 5($28)        # $17 = [0x80001005]的byte1 = 0xEF -> 0xFFFFFFEF (符号扩展)
    lb   $18, 6($28)        # $18 = [0x80001006]的byte2 = 0xCD -> 0xFFFFFFCD (符号扩展)
    lb   $19, 7($28)        # $19 = [0x80001007]的byte3 = 0xAB -> 0xFFFFFFAB (符号扩展)
    
    # 使用负偏移测试
    addiu $29, $28, 32      # $29 = $28 + 32
    sw   $1, -4($29)        # [0x80001000 + 32 - 4] = [0x8000101C] = 0x12345678
    lw   $20, -4($29)       # $20 = [0x8000101C] = 0x12345678
    
    # 边界条件：大偏移
    sw   $2, 100($28)       # [0x80001064] = 0xABCDEF00
    lw   $21, 100($28)      # $21 = [0x80001064] = 0xABCDEF00
    
    # 连续存储和加载测试
    ori  $22, $0, 0x1111
    ori  $23, $0, 0x2222
    ori  $24, $0, 0x3333
    sw   $22, 200($28)
    sw   $23, 204($28)
    sw   $24, 208($28)
    lw   $25, 200($28)      # $25 = 0x1111
    lw   $26, 204($28)      # $26 = 0x2222
    lw   $27, 208($28)      # $27 = 0x3333
    
    # 结束
    ori  $31, $0, 0xDEAD
    
_end:
    beq  $0, $0, _end
    nop
